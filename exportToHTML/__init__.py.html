<html>
<head>
<title>__init__.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
__init__.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot;JSON (JavaScript Object Notation) &lt;https://json.org&gt; is a subset of 
JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data 
interchange format. 
 
:mod:`json` exposes an API familiar to users of the standard library 
:mod:`marshal` and :mod:`pickle` modules.  It is derived from a 
version of the externally maintained simplejson library. 
 
Encoding basic Python object hierarchies:: 
 
    &gt;&gt;&gt; import json 
    &gt;&gt;&gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}]) 
    '[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]' 
    &gt;&gt;&gt; print(json.dumps(&quot;\&quot;foo\bar&quot;)) 
    &quot;\&quot;foo\bar&quot; 
    &gt;&gt;&gt; print(json.dumps('\u1234')) 
    &quot;\u1234&quot; 
    &gt;&gt;&gt; print(json.dumps('\\')) 
    &quot;\\&quot; 
    &gt;&gt;&gt; print(json.dumps({&quot;c&quot;: 0, &quot;b&quot;: 0, &quot;a&quot;: 0}, sort_keys=True)) 
    {&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0} 
    &gt;&gt;&gt; from io import StringIO 
    &gt;&gt;&gt; io = StringIO() 
    &gt;&gt;&gt; json.dump(['streaming API'], io) 
    &gt;&gt;&gt; io.getvalue() 
    '[&quot;streaming API&quot;]' 
 
Compact encoding:: 
 
    &gt;&gt;&gt; import json 
    &gt;&gt;&gt; mydict = {'4': 5, '6': 7} 
    &gt;&gt;&gt; json.dumps([1,2,3,mydict], separators=(',', ':')) 
    '[1,2,3,{&quot;4&quot;:5,&quot;6&quot;:7}]' 
 
Pretty printing:: 
 
    &gt;&gt;&gt; import json 
    &gt;&gt;&gt; print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4)) 
    { 
        &quot;4&quot;: 5, 
        &quot;6&quot;: 7 
    } 
 
Decoding JSON:: 
 
    &gt;&gt;&gt; import json 
    &gt;&gt;&gt; obj = ['foo', {'bar': ['baz', None, 1.0, 2]}] 
    &gt;&gt;&gt; json.loads('[&quot;foo&quot;, {&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]}]') == obj 
    True 
    &gt;&gt;&gt; json.loads('&quot;\\&quot;foo\\bar&quot;') == '&quot;foo\x08ar' 
    True 
    &gt;&gt;&gt; from io import StringIO 
    &gt;&gt;&gt; io = StringIO('[&quot;streaming API&quot;]') 
    &gt;&gt;&gt; json.load(io)[0] == 'streaming API' 
    True 
 
Specializing JSON object decoding:: 
 
    &gt;&gt;&gt; import json 
    &gt;&gt;&gt; def as_complex(dct): 
    ...     if '__complex__' in dct: 
    ...         return complex(dct['real'], dct['imag']) 
    ...     return dct 
    ... 
    &gt;&gt;&gt; json.loads('{&quot;__complex__&quot;: true, &quot;real&quot;: 1, &quot;imag&quot;: 2}', 
    ...     object_hook=as_complex) 
    (1+2j) 
    &gt;&gt;&gt; from decimal import Decimal 
    &gt;&gt;&gt; json.loads('1.1', parse_float=Decimal) == Decimal('1.1') 
    True 
 
Specializing JSON object encoding:: 
 
    &gt;&gt;&gt; import json 
    &gt;&gt;&gt; def encode_complex(obj): 
    ...     if isinstance(obj, complex): 
    ...         return [obj.real, obj.imag] 
    ...     raise TypeError(f'Object of type {obj.__class__.__name__} ' 
    ...                     f'is not JSON serializable') 
    ... 
    &gt;&gt;&gt; json.dumps(2 + 1j, default=encode_complex) 
    '[2.0, 1.0]' 
    &gt;&gt;&gt; json.JSONEncoder(default=encode_complex).encode(2 + 1j) 
    '[2.0, 1.0]' 
    &gt;&gt;&gt; ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j)) 
    '[2.0, 1.0]' 
 
 
Using json.tool from the shell to validate and pretty-print:: 
 
    $ echo '{&quot;json&quot;:&quot;obj&quot;}' | python -m json.tool 
    { 
        &quot;json&quot;: &quot;obj&quot; 
    } 
    $ echo '{ 1.2:3.4}' | python -m json.tool 
    Expecting property name enclosed in double quotes: line 1 column 3 (char 2) 
&quot;&quot;&quot;</span>
<span class="s1">__version__ = </span><span class="s2">'2.0.9'</span>
<span class="s1">__all__ = [</span>
    <span class="s2">'dump'</span><span class="s3">, </span><span class="s2">'dumps'</span><span class="s3">, </span><span class="s2">'load'</span><span class="s3">, </span><span class="s2">'loads'</span><span class="s3">,</span>
    <span class="s2">'JSONDecoder'</span><span class="s3">, </span><span class="s2">'JSONDecodeError'</span><span class="s3">, </span><span class="s2">'JSONEncoder'</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s1">__author__ = </span><span class="s2">'Bob Ippolito &lt;bob@redivi.com&gt;'</span>

<span class="s3">from </span><span class="s1">.decoder </span><span class="s3">import </span><span class="s1">JSONDecoder</span><span class="s3">, </span><span class="s1">JSONDecodeError</span>
<span class="s3">from </span><span class="s1">.encoder </span><span class="s3">import </span><span class="s1">JSONEncoder</span>
<span class="s3">import </span><span class="s1">codecs</span>

<span class="s1">_default_encoder = JSONEncoder(</span>
    <span class="s1">skipkeys=</span><span class="s3">False,</span>
    <span class="s1">ensure_ascii=</span><span class="s3">True,</span>
    <span class="s1">check_circular=</span><span class="s3">True,</span>
    <span class="s1">allow_nan=</span><span class="s3">True,</span>
    <span class="s1">indent=</span><span class="s3">None,</span>
    <span class="s1">separators=</span><span class="s3">None,</span>
    <span class="s1">default=</span><span class="s3">None,</span>
<span class="s1">)</span>

<span class="s3">def </span><span class="s1">dump(obj</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">skipkeys=</span><span class="s3">False, </span><span class="s1">ensure_ascii=</span><span class="s3">True, </span><span class="s1">check_circular=</span><span class="s3">True,</span>
        <span class="s1">allow_nan=</span><span class="s3">True, </span><span class="s1">cls=</span><span class="s3">None, </span><span class="s1">indent=</span><span class="s3">None, </span><span class="s1">separators=</span><span class="s3">None,</span>
        <span class="s1">default=</span><span class="s3">None, </span><span class="s1">sort_keys=</span><span class="s3">False, </span><span class="s1">**kw):</span>
    <span class="s0">&quot;&quot;&quot;Serialize ``obj`` as a JSON formatted stream to ``fp`` (a 
    ``.write()``-supporting file-like object). 
 
    If ``skipkeys`` is true then ``dict`` keys that are not basic types 
    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped 
    instead of raising a ``TypeError``. 
 
    If ``ensure_ascii`` is false, then the strings written to ``fp`` can 
    contain non-ASCII characters if they appear in strings contained in 
    ``obj``. Otherwise, all such characters are escaped in JSON strings. 
 
    If ``check_circular`` is false, then the circular reference check 
    for container types will be skipped and a circular reference will 
    result in an ``RecursionError`` (or worse). 
 
    If ``allow_nan`` is false, then it will be a ``ValueError`` to 
    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) 
    in strict compliance of the JSON specification, instead of using the 
    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``). 
 
    If ``indent`` is a non-negative integer, then JSON array elements and 
    object members will be pretty-printed with that indent level. An indent 
    level of 0 will only insert newlines. ``None`` is the most compact 
    representation. 
 
    If specified, ``separators`` should be an ``(item_separator, key_separator)`` 
    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and 
    ``(',', ': ')`` otherwise.  To get the most compact JSON representation, 
    you should specify ``(',', ':')`` to eliminate whitespace. 
 
    ``default(obj)`` is a function that should return a serializable version 
    of obj or raise TypeError. The default simply raises TypeError. 
 
    If *sort_keys* is true (default: ``False``), then the output of 
    dictionaries will be sorted by key. 
 
    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the 
    ``.default()`` method to serialize additional types), specify it with 
    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used. 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># cached encoder</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">skipkeys </span><span class="s3">and </span><span class="s1">ensure_ascii </span><span class="s3">and</span>
        <span class="s1">check_circular </span><span class="s3">and </span><span class="s1">allow_nan </span><span class="s3">and</span>
        <span class="s1">cls </span><span class="s3">is None and </span><span class="s1">indent </span><span class="s3">is None and </span><span class="s1">separators </span><span class="s3">is None and</span>
        <span class="s1">default </span><span class="s3">is None and not </span><span class="s1">sort_keys </span><span class="s3">and not </span><span class="s1">kw):</span>
        <span class="s1">iterable = _default_encoder.iterencode(obj)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">cls = JSONEncoder</span>
        <span class="s1">iterable = cls(skipkeys=skipkeys</span><span class="s3">, </span><span class="s1">ensure_ascii=ensure_ascii</span><span class="s3">,</span>
            <span class="s1">check_circular=check_circular</span><span class="s3">, </span><span class="s1">allow_nan=allow_nan</span><span class="s3">, </span><span class="s1">indent=indent</span><span class="s3">,</span>
            <span class="s1">separators=separators</span><span class="s3">,</span>
            <span class="s1">default=default</span><span class="s3">, </span><span class="s1">sort_keys=sort_keys</span><span class="s3">, </span><span class="s1">**kw).iterencode(obj)</span>
    <span class="s4"># could accelerate with writelines in some versions of Python, at</span>
    <span class="s4"># a debuggability cost</span>
    <span class="s3">for </span><span class="s1">chunk </span><span class="s3">in </span><span class="s1">iterable:</span>
        <span class="s1">fp.write(chunk)</span>


<span class="s3">def </span><span class="s1">dumps(obj</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">skipkeys=</span><span class="s3">False, </span><span class="s1">ensure_ascii=</span><span class="s3">True, </span><span class="s1">check_circular=</span><span class="s3">True,</span>
        <span class="s1">allow_nan=</span><span class="s3">True, </span><span class="s1">cls=</span><span class="s3">None, </span><span class="s1">indent=</span><span class="s3">None, </span><span class="s1">separators=</span><span class="s3">None,</span>
        <span class="s1">default=</span><span class="s3">None, </span><span class="s1">sort_keys=</span><span class="s3">False, </span><span class="s1">**kw):</span>
    <span class="s0">&quot;&quot;&quot;Serialize ``obj`` to a JSON formatted ``str``. 
 
    If ``skipkeys`` is true then ``dict`` keys that are not basic types 
    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped 
    instead of raising a ``TypeError``. 
 
    If ``ensure_ascii`` is false, then the return value can contain non-ASCII 
    characters if they appear in strings contained in ``obj``. Otherwise, all 
    such characters are escaped in JSON strings. 
 
    If ``check_circular`` is false, then the circular reference check 
    for container types will be skipped and a circular reference will 
    result in an ``RecursionError`` (or worse). 
 
    If ``allow_nan`` is false, then it will be a ``ValueError`` to 
    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in 
    strict compliance of the JSON specification, instead of using the 
    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``). 
 
    If ``indent`` is a non-negative integer, then JSON array elements and 
    object members will be pretty-printed with that indent level. An indent 
    level of 0 will only insert newlines. ``None`` is the most compact 
    representation. 
 
    If specified, ``separators`` should be an ``(item_separator, key_separator)`` 
    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and 
    ``(',', ': ')`` otherwise.  To get the most compact JSON representation, 
    you should specify ``(',', ':')`` to eliminate whitespace. 
 
    ``default(obj)`` is a function that should return a serializable version 
    of obj or raise TypeError. The default simply raises TypeError. 
 
    If *sort_keys* is true (default: ``False``), then the output of 
    dictionaries will be sorted by key. 
 
    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the 
    ``.default()`` method to serialize additional types), specify it with 
    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used. 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># cached encoder</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">skipkeys </span><span class="s3">and </span><span class="s1">ensure_ascii </span><span class="s3">and</span>
        <span class="s1">check_circular </span><span class="s3">and </span><span class="s1">allow_nan </span><span class="s3">and</span>
        <span class="s1">cls </span><span class="s3">is None and </span><span class="s1">indent </span><span class="s3">is None and </span><span class="s1">separators </span><span class="s3">is None and</span>
        <span class="s1">default </span><span class="s3">is None and not </span><span class="s1">sort_keys </span><span class="s3">and not </span><span class="s1">kw):</span>
        <span class="s3">return </span><span class="s1">_default_encoder.encode(obj)</span>
    <span class="s3">if </span><span class="s1">cls </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">cls = JSONEncoder</span>
    <span class="s3">return </span><span class="s1">cls(</span>
        <span class="s1">skipkeys=skipkeys</span><span class="s3">, </span><span class="s1">ensure_ascii=ensure_ascii</span><span class="s3">,</span>
        <span class="s1">check_circular=check_circular</span><span class="s3">, </span><span class="s1">allow_nan=allow_nan</span><span class="s3">, </span><span class="s1">indent=indent</span><span class="s3">,</span>
        <span class="s1">separators=separators</span><span class="s3">, </span><span class="s1">default=default</span><span class="s3">, </span><span class="s1">sort_keys=sort_keys</span><span class="s3">,</span>
        <span class="s1">**kw).encode(obj)</span>


<span class="s1">_default_decoder = JSONDecoder(object_hook=</span><span class="s3">None, </span><span class="s1">object_pairs_hook=</span><span class="s3">None</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">detect_encoding(b):</span>
    <span class="s1">bstartswith = b.startswith</span>
    <span class="s3">if </span><span class="s1">bstartswith((codecs.BOM_UTF32_BE</span><span class="s3">, </span><span class="s1">codecs.BOM_UTF32_LE)):</span>
        <span class="s3">return </span><span class="s2">'utf-32'</span>
    <span class="s3">if </span><span class="s1">bstartswith((codecs.BOM_UTF16_BE</span><span class="s3">, </span><span class="s1">codecs.BOM_UTF16_LE)):</span>
        <span class="s3">return </span><span class="s2">'utf-16'</span>
    <span class="s3">if </span><span class="s1">bstartswith(codecs.BOM_UTF8):</span>
        <span class="s3">return </span><span class="s2">'utf-8-sig'</span>

    <span class="s3">if </span><span class="s1">len(b) &gt;= </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">b[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s4"># 00 00 -- -- - utf-32-be</span>
            <span class="s4"># 00 XX -- -- - utf-16-be</span>
            <span class="s3">return </span><span class="s2">'utf-16-be' </span><span class="s3">if </span><span class="s1">b[</span><span class="s5">1</span><span class="s1">] </span><span class="s3">else </span><span class="s2">'utf-32-be'</span>
        <span class="s3">if not </span><span class="s1">b[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s4"># XX 00 00 00 - utf-32-le</span>
            <span class="s4"># XX 00 00 XX - utf-16-le</span>
            <span class="s4"># XX 00 XX -- - utf-16-le</span>
            <span class="s3">return </span><span class="s2">'utf-16-le' </span><span class="s3">if </span><span class="s1">b[</span><span class="s5">2</span><span class="s1">] </span><span class="s3">or </span><span class="s1">b[</span><span class="s5">3</span><span class="s1">] </span><span class="s3">else </span><span class="s2">'utf-32-le'</span>
    <span class="s3">elif </span><span class="s1">len(b) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">b[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s4"># 00 XX - utf-16-be</span>
            <span class="s3">return </span><span class="s2">'utf-16-be'</span>
        <span class="s3">if not </span><span class="s1">b[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s4"># XX 00 - utf-16-le</span>
            <span class="s3">return </span><span class="s2">'utf-16-le'</span>
    <span class="s4"># default</span>
    <span class="s3">return </span><span class="s2">'utf-8'</span>


<span class="s3">def </span><span class="s1">load(fp</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">cls=</span><span class="s3">None, </span><span class="s1">object_hook=</span><span class="s3">None, </span><span class="s1">parse_float=</span><span class="s3">None,</span>
        <span class="s1">parse_int=</span><span class="s3">None, </span><span class="s1">parse_constant=</span><span class="s3">None, </span><span class="s1">object_pairs_hook=</span><span class="s3">None, </span><span class="s1">**kw):</span>
    <span class="s0">&quot;&quot;&quot;Deserialize ``fp`` (a ``.read()``-supporting file-like object containing 
    a JSON document) to a Python object. 
 
    ``object_hook`` is an optional function that will be called with the 
    result of any object literal decode (a ``dict``). The return value of 
    ``object_hook`` will be used instead of the ``dict``. This feature 
    can be used to implement custom decoders (e.g. JSON-RPC class hinting). 
 
    ``object_pairs_hook`` is an optional function that will be called with the 
    result of any object literal decoded with an ordered list of pairs.  The 
    return value of ``object_pairs_hook`` will be used instead of the ``dict``. 
    This feature can be used to implement custom decoders.  If ``object_hook`` 
    is also defined, the ``object_pairs_hook`` takes priority. 
 
    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls`` 
    kwarg; otherwise ``JSONDecoder`` is used. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">loads(fp.read()</span><span class="s3">,</span>
        <span class="s1">cls=cls</span><span class="s3">, </span><span class="s1">object_hook=object_hook</span><span class="s3">,</span>
        <span class="s1">parse_float=parse_float</span><span class="s3">, </span><span class="s1">parse_int=parse_int</span><span class="s3">,</span>
        <span class="s1">parse_constant=parse_constant</span><span class="s3">, </span><span class="s1">object_pairs_hook=object_pairs_hook</span><span class="s3">, </span><span class="s1">**kw)</span>


<span class="s3">def </span><span class="s1">loads(s</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">cls=</span><span class="s3">None, </span><span class="s1">object_hook=</span><span class="s3">None, </span><span class="s1">parse_float=</span><span class="s3">None,</span>
        <span class="s1">parse_int=</span><span class="s3">None, </span><span class="s1">parse_constant=</span><span class="s3">None, </span><span class="s1">object_pairs_hook=</span><span class="s3">None, </span><span class="s1">**kw):</span>
    <span class="s0">&quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance 
    containing a JSON document) to a Python object. 
 
    ``object_hook`` is an optional function that will be called with the 
    result of any object literal decode (a ``dict``). The return value of 
    ``object_hook`` will be used instead of the ``dict``. This feature 
    can be used to implement custom decoders (e.g. JSON-RPC class hinting). 
 
    ``object_pairs_hook`` is an optional function that will be called with the 
    result of any object literal decoded with an ordered list of pairs.  The 
    return value of ``object_pairs_hook`` will be used instead of the ``dict``. 
    This feature can be used to implement custom decoders.  If ``object_hook`` 
    is also defined, the ``object_pairs_hook`` takes priority. 
 
    ``parse_float``, if specified, will be called with the string 
    of every JSON float to be decoded. By default this is equivalent to 
    float(num_str). This can be used to use another datatype or parser 
    for JSON floats (e.g. decimal.Decimal). 
 
    ``parse_int``, if specified, will be called with the string 
    of every JSON int to be decoded. By default this is equivalent to 
    int(num_str). This can be used to use another datatype or parser 
    for JSON integers (e.g. float). 
 
    ``parse_constant``, if specified, will be called with one of the 
    following strings: -Infinity, Infinity, NaN. 
    This can be used to raise an exception if invalid JSON numbers 
    are encountered. 
 
    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls`` 
    kwarg; otherwise ``JSONDecoder`` is used. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s3">if </span><span class="s1">s.startswith(</span><span class="s2">'</span><span class="s3">\ufeff</span><span class="s2">'</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">JSONDecodeError(</span><span class="s2">&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;</span><span class="s3">,</span>
                                  <span class="s1">s</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">bytearray)):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">f'the JSON object must be str, bytes or bytearray, '</span>
                            <span class="s2">f'not </span><span class="s3">{</span><span class="s1">s.__class__.__name__</span><span class="s3">}</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">s = s.decode(detect_encoding(s)</span><span class="s3">, </span><span class="s2">'surrogatepass'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">(cls </span><span class="s3">is None and </span><span class="s1">object_hook </span><span class="s3">is None and</span>
            <span class="s1">parse_int </span><span class="s3">is None and </span><span class="s1">parse_float </span><span class="s3">is None and</span>
            <span class="s1">parse_constant </span><span class="s3">is None and </span><span class="s1">object_pairs_hook </span><span class="s3">is None and not </span><span class="s1">kw):</span>
        <span class="s3">return </span><span class="s1">_default_decoder.decode(s)</span>
    <span class="s3">if </span><span class="s1">cls </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">cls = JSONDecoder</span>
    <span class="s3">if </span><span class="s1">object_hook </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">kw[</span><span class="s2">'object_hook'</span><span class="s1">] = object_hook</span>
    <span class="s3">if </span><span class="s1">object_pairs_hook </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">kw[</span><span class="s2">'object_pairs_hook'</span><span class="s1">] = object_pairs_hook</span>
    <span class="s3">if </span><span class="s1">parse_float </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">kw[</span><span class="s2">'parse_float'</span><span class="s1">] = parse_float</span>
    <span class="s3">if </span><span class="s1">parse_int </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">kw[</span><span class="s2">'parse_int'</span><span class="s1">] = parse_int</span>
    <span class="s3">if </span><span class="s1">parse_constant </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">kw[</span><span class="s2">'parse_constant'</span><span class="s1">] = parse_constant</span>
    <span class="s3">return </span><span class="s1">cls(**kw).decode(s)</span>
</pre>
</body>
</html>